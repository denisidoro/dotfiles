#!/usr/bin/env bash
set -euo pipefail

source "${DOTFILES}/scripts/core/main.sh"

##? Command cheatsheet tool
##?
##? Usage:
##?     cheats [options]
##?
##? Options:
##?     --print                               Prevent script execution [default: false]
##?     --no-interpolation                    Prevent argument interpolation [default: false]
##?     -c --config-folder <config-folder>    Config folder with cheatsheets

docs::eval "$@"



# =======================
# str 
# =======================

str::length() {
    awk '{print length}'
}

str::sub() {
    local -r start="${1:-0}"
    local -r finish="${2:-99999}"

    cut -c "$((start + 1))-$((finish - 1))"
}

str::column() {
    local -r n="${1:-}"

    if [ -n "$n" ]; then
        awk "{print \$$n}"
    else
        cat
    fi
}

str::last_paragraph_line() {
    awk '(!NF) { exit } { print $0 }' \
        | tail -n1
}


# =======================
# selection
# =======================

selection::core() {
    cut -d'^' -f2
}

selection::tags() {
    cut -d'^' -f1
}

selection::core_is_comment() {
    grep -qE '^#'
}

selection::command() {
    local -r selection="$1"
    local -r cheat="$2"

    local -r core="$(echo $selection | selection::core)"

    if echo "$core" | selection::core_is_comment; then
        grep "$core" "$cheat" -A999 \
          | str::last_paragraph_line
    else
        echo "$core"
    fi
}


# =======================
# arg
# =======================

arg::fn() {
    awk -F'---' '{print $1}'
}

arg::opts() {
    awk -F'---' '{print $2}'
}

arg::interpolate() {
    local -r arg="$1"
    local -r value="$2"

    sed "s|<${arg}>|\"${value}\"|g"
}

arg::next() {
    grep -Eo '<[0-9a-zA-Z\-_]+>' \
      | head -n1 \
      | tr -d '<' \
      | tr -d '>'
}

arg::pick() {
    local -r arg="$1"
    local -r cheat="$2"

    local -r prefix="$ ${arg}:"
    local -r length="$(echo "$prefix" | str::length)"
    local -r arg_description="$(grep "$prefix" "$cheat" | str::sub $((length + 1)))"

    local -r fn="$(echo "$arg_description" | arg::fn)"
    local -r args_str="$(echo "$arg_description" | arg::opts | tr ' ' '\n' || echo "")"
    local arg_name=""

    for arg_str in $args_str; do
        if [ -z $arg_name ]; then
           arg_name="$(echo "$arg_str" | str::sub 2)" 
        else
           eval "local $arg_name"='$arg_str'
           arg_name=""
        fi
    done

    if [ -n "$fn" ]; then
        eval "$fn" | ui::pick --prompt "$arg: " --header-lines "${headers:-0}" | str::column "${column:-}"
    else
        printf "\033[0;36m${arg}:\033[0;0m " > /dev/tty
        read value
        ui::clear_previous_line > /dev/tty
        printf "$value"
    fi
}


# =======================
# cheat
# =======================

cheat::find() {
	find "${cheat_folder:-$DOTFILES/cheatsheets}" -iname '*.cheat'
}

cheat::read_many() {
    for cheat in $(cat); do
        awk '
        function color(c,s) {
           printf("\033[%dm%s\033[0m",30+c,s)
        }
        
        /^%/ { tags=substr($0, 3); next }
        /^#/ { print color(3, tags"^") color(4, $0); next }
        /^\$/ { next }
        NF { print color(3, tags"^") color(7, $0); next }' "$cheat"
    done
}

cheat::from_selection() {
    local -r cheats="$1"
    local -r selection="$2"
    
    local -r tags="$(echo "$selection" | selection::tags)"

    for cheat in $cheats; do
        if grep -q "% $tags" "$cheat"; then
            echo "$cheat"
            break
        fi
    done
}


# =======================
# ui
# =======================

ui::pick() {
    fzf --inline-info "$@"
}

ui::select() {
    local -r cheats="$1"

    echo "$cheats" \
        | cheat::read_many \
        | ui::pick -i --ansi --delimiter '\^' --with-nth 2
}

ui::clear_previous_line() {
    tput cuu1 && tput el || true
}



# =======================
# misc
# =======================


# no-op hack to set dependency order resolution
dep() {
    :
}

main() {
    local -r cheats="$(cheat::find)"
    local -r selection="$(ui::select "$cheats")"
    local -r cheat="$(cheat::from_selection "$cheats" "$selection")"
    local cmd="$(selection::command "$selection" "$cheat")"
    local arg value

    if $no_interpolation; then
        echo "$cmd"
        exit 0
    fi

    while true; do
        arg="$(echo "$cmd" | arg::next || echo "")"
        if [ -z "$arg" ]; then 
            break
        fi

        value="$(arg::pick "$arg" "$cheat" || echo "")"
        if [ -z "$value" ]; then
            echo "$cmd"
            exit 0
        fi

        eval "local $arg"='$value'
        cmd="$(echo "$cmd" | arg::interpolate "$arg" "$value")"
    done

    if $print; then
        echo "$cmd"
    else
        eval "$cmd"
    fi
}

main "$@"