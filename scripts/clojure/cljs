#!/usr/bin/env bash
set -euo pipefail

source "${DOTFILES}/scripts/core/main.sh"

##? Calls a Clojurescript script
##?
##? Usage:
##?    cljs [options] <script> [-- <arguments>...]
##?
##? Options:
##?    --classpath <classpath>   Colon-delimited list for source directories and JARs
##?    --namespace <namespace>   Namespace to be executed [default: dot]
##?    --fn <fn>                 Function to be executed [default: -main]
##?    --noreturn                Remove <fn>'s return value from stdout [default: false]
##?
##? Example:
##?    cljs edn -- get :a

function format_response() {
	if $noreturn; then
		local readonly lines="$(echo "$1" | wc -l | xargs)"
		if [[ $lines < 2 ]]; then
			echo ""
		else
			echo "$1" | tail -n +2
		fi
	else
		echo "$1"
	fi
}

function call_cljs() {
	local readonly classpath="$1"
		readonly namespace="$2"
		readonly fn="$3"
	shift 3
	dot clojure lumo \
	   --auto-cache \
	   --classpath "${classpath}" \
	   --eval "(require '[${namespace} :as ns]) (ns/${fn} $@)"
}

docs::eval "$@"

# cd to pertinent folder so that the package.json is read
pushd "${DOTFILES}/scripts" > /dev/null

# set constants
classpath="${DOTFILES}/scripts/clojure/:${classpath:-}"
full_namespace="${namespace}.${script}"
args=""

# quote variables
if ! coll::is_empty "${arguments[@]:-}"; then
	for arg in "${arguments[@]:-}"; do
	    escaped_arg="$(echo "$arg" | sed -E 's|\"|\\"|g')"
	    args="$args \"${escaped_arg}\""
	done
fi

# call script and format it
response="$(call_cljs "$classpath" "$full_namespace" "$fn" "${args[@]}")"
exit_code=$?
format_response "$response"

# cd back to calling folder
popd > /dev/null

# forward cljs exit code
exit $exit_code
